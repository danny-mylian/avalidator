// @flow
'use strict';

import type {
  ValidatorFn,
  ValidationError,
  ValidationResult }  from '../types/validation';

import type { Map }   from '../types/shared';

import type {
  ConfigError,
  ConfigProper,
  ConfigStatus }      from '../types/config';


const STATUS_ERROR: string = 'error';
const STATUS_OK: string = 'ok';

/*
 * Base class AbstractValidator
 */
class AbstractValidator {

  data: any;
  rules: any;
  valid: boolean;

  // TODO
  // 2 options here: support for plain js data object as it is now
  // and pass a form directly via `dom-adapter`
  constructor(rules: any, data: any /* Observable? */) {
    
    this._validateInputConfig(data, rules, (result: ConfigStatus) => {
      switch (result.status) {
        // case malformed rules object -> throw early
        case STATUS_ERROR:
          return this._raiseConfigError(result.errorString);
        default:
          this.data = data;
          this.rules = rules;
          this.valid = true;
      }
    });

  }

  /**
   * Internal helper method
   * Execute each partially applied [Function]
   * generated by the `RuleDefBuilder.compose` method
   * from the rules object
   *
   * @private {Function}
   */
  _mergeErrors(source: Map<*>, rules: Map<*>): Map<Array<ValidationResult<*>>> {
    return Object.keys(source).reduce((acc: Map<Array<ValidationResult<*>>>, c: string) => {
      acc[c] = rules[c](source[c]);
      //console.log(acc[c])
      if (acc[c].length) {
        this.valid = false;
      }
      return acc;
    }, {});
  }

  /**
   * Internal helper method
   * Called from the constructor in case of configuration error
   * @private {Function}
   */
  _raiseConfigError(error: string) {
    throw new SyntaxError(error);
  }

  /**
   * Internal helper method
   * Invoked from the constructor to ensure that rules are correct
   * @private {Function}
   */
  _validateInputConfig(source: Map<*>, rules: Map<*>, callback: (result: ConfigStatus) => void) {
    if (Object.keys(source).length > Object.keys(rules).length) {
      return callback({
        status: STATUS_ERROR,
        errorCode: 1,
        errorString: 'Rules object doesn\'t match the source'
      });
    } else {
      return callback({
        status: STATUS_OK
      });
    }
  }

  /*
   *
   *
   * @return {Map<Array<ValidationResult<*>>>}
   */
  validate(/* options */): Map<Array<ValidationResult<*>>> {
    return this._mergeErrors(this.data, this.rules);
  }

}

module.exports = {
  AbstractValidator
}
